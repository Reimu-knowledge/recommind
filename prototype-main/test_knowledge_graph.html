<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>知识图谱测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #333;
        }
        .result {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .success {
            color: #28a745;
        }
        .error {
            color: #dc3545;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        .graph-container {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>知识图谱功能测试</h1>
        
        <div class="test-section">
            <h3>1. API连接测试</h3>
            <button onclick="testAPI()">测试API连接</button>
            <div id="api-result" class="result"></div>
        </div>
        
        <div class="test-section">
            <h3>2. 数据解析测试</h3>
            <button onclick="testDataParsing()">测试数据解析</button>
            <div id="parse-result" class="result"></div>
        </div>
        
        <div class="test-section">
            <h3>3. 知识图谱可视化测试</h3>
            <button onclick="testVisualization()">测试可视化</button>
            <div id="graph-container" class="graph-container"></div>
            <div id="viz-result" class="result"></div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let apiData = null;
        
        // 测试API连接
        async function testAPI() {
            const resultDiv = document.getElementById('api-result');
            resultDiv.innerHTML = '正在测试API连接...';
            
            try {
                const response = await fetch('/api/knowledge-graph');
                if (response.ok) {
                    const csvText = await response.text();
                    apiData = csvText;
                    resultDiv.innerHTML = `<span class="success">✅ API连接成功</span>\n\n数据长度: ${csvText.length} 字符\n\n前5行数据:\n${csvText.split('\n').slice(0, 5).join('\n')}`;
                } else {
                    resultDiv.innerHTML = `<span class="error">❌ API连接失败: ${response.status} ${response.statusText}</span>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<span class="error">❌ API连接异常: ${error.message}</span>`;
            }
        }
        
        // 测试数据解析
        function testDataParsing() {
            const resultDiv = document.getElementById('parse-result');
            
            if (!apiData) {
                resultDiv.innerHTML = '<span class="error">❌ 请先测试API连接</span>';
                return;
            }
            
            try {
                const lines = apiData.trim().split('\n');
                const nodeMap = new Map();
                const links = [];
                
                lines.forEach(line => {
                    if (!line.trim()) return;
                    
                    const parts = line.split(',');
                    if (parts.length >= 5) {
                        const sourceName = parts[0].trim();
                        const sourceId = parts[1].trim();
                        const relation = parts[2].trim();
                        const targetName = parts[3].trim();
                        const targetId = parts[4].trim();
                        
                        // 添加节点
                        if (!nodeMap.has(sourceId)) {
                            nodeMap.set(sourceId, {
                                id: sourceId,
                                name: sourceName,
                                level: 0
                            });
                        }
                        
                        if (!nodeMap.has(targetId)) {
                            nodeMap.set(targetId, {
                                id: targetId,
                                name: targetName,
                                level: 0
                            });
                        }
                        
                        // 添加连接
                        links.push({
                            source: sourceId,
                            target: targetId,
                            relation: relation
                        });
                    }
                });
                
                // 构建以k0为中心的子图
                const centerId = 'k0';
                const centerNode = nodeMap.get(centerId);
                
                if (centerNode) {
                    const neighbors = new Set();
                    const relevantLinks = [];
                    
                    links.forEach(link => {
                        if (link.source === centerId) {
                            neighbors.add(link.target);
                            relevantLinks.push(link);
                        } else if (link.target === centerId) {
                            neighbors.add(link.source);
                            relevantLinks.push(link);
                        }
                    });
                    
                    const subgraphNodes = [centerNode];
                    neighbors.forEach(neighborId => {
                        if (nodeMap.has(neighborId)) {
                            subgraphNodes.push(nodeMap.get(neighborId));
                        }
                    });
                    
                    resultDiv.innerHTML = `<span class="success">✅ 数据解析成功</span>\n\n总节点数: ${nodeMap.size}\n总连接数: ${links.length}\n\n子图信息:\n中心节点: ${centerNode.name} (${centerId})\n邻居节点数: ${neighbors.size}\n子图节点数: ${subgraphNodes.length}\n子图连接数: ${relevantLinks.length}\n\n邻居节点:\n${Array.from(neighbors).slice(0, 5).map(id => `- ${nodeMap.get(id).name} (${id})`).join('\n')}`;
                } else {
                    resultDiv.innerHTML = '<span class="error">❌ 未找到根节点k0</span>';
                }
                
            } catch (error) {
                resultDiv.innerHTML = `<span class="error">❌ 数据解析异常: ${error.message}</span>`;
            }
        }
        
        // 测试可视化
        function testVisualization() {
            const container = document.getElementById('graph-container');
            const resultDiv = document.getElementById('viz-result');
            
            if (!apiData) {
                resultDiv.innerHTML = '<span class="error">❌ 请先测试API连接</span>';
                return;
            }
            
            try {
                // 清除之前的内容
                container.innerHTML = '';
                
                // 解析数据
                const lines = apiData.trim().split('\n');
                const nodeMap = new Map();
                const links = [];
                
                lines.forEach(line => {
                    if (!line.trim()) return;
                    
                    const parts = line.split(',');
                    if (parts.length >= 5) {
                        const sourceName = parts[0].trim();
                        const sourceId = parts[1].trim();
                        const relation = parts[2].trim();
                        const targetName = parts[3].trim();
                        const targetId = parts[4].trim();
                        
                        if (!nodeMap.has(sourceId)) {
                            nodeMap.set(sourceId, {
                                id: sourceId,
                                name: sourceName,
                                level: 0
                            });
                        }
                        
                        if (!nodeMap.has(targetId)) {
                            nodeMap.set(targetId, {
                                id: targetId,
                                name: targetName,
                                level: 0
                            });
                        }
                        
                        links.push({
                            source: sourceId,
                            target: targetId,
                            relation: relation
                        });
                    }
                });
                
                // 构建以k0为中心的子图
                const centerId = 'k0';
                const centerNode = nodeMap.get(centerId);
                
                if (!centerNode) {
                    resultDiv.innerHTML = '<span class="error">❌ 未找到根节点k0</span>';
                    return;
                }
                
                const neighbors = new Set();
                const relevantLinks = [];
                
                links.forEach(link => {
                    if (link.source === centerId) {
                        neighbors.add(link.target);
                        relevantLinks.push(link);
                    } else if (link.target === centerId) {
                        neighbors.add(link.source);
                        relevantLinks.push(link);
                    }
                });
                
                const subgraphNodes = [centerNode];
                neighbors.forEach(neighborId => {
                    if (nodeMap.has(neighborId)) {
                        subgraphNodes.push(nodeMap.get(neighborId));
                    }
                });
                
                // 创建SVG
                const width = container.offsetWidth;
                const height = container.offsetHeight;
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // 创建力导向图
                const simulation = d3.forceSimulation(subgraphNodes)
                    .force('link', d3.forceLink(relevantLinks).id(d => d.id).distance(100))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(width / 2, height / 2));
                
                // 绘制连线
                const link = svg.append('g')
                    .selectAll('line')
                    .data(relevantLinks)
                    .join('line')
                    .attr('stroke', '#999')
                    .attr('stroke-opacity', 0.6)
                    .attr('stroke-width', 2);
                
                // 绘制节点
                const node = svg.append('g')
                    .selectAll('g')
                    .data(subgraphNodes)
                    .join('g')
                    .style('cursor', 'pointer');
                
                // 节点圆圈
                node.append('circle')
                    .attr('r', d => d.id === centerId ? 20 : 15)
                    .attr('fill', d => d.id === centerId ? '#ff6b6b' : '#4ecdc4')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', d => d.id === centerId ? 3 : 2);
                
                // 节点文字
                node.append('text')
                    .text(d => d.name.length > 8 ? d.name.slice(0, 8) + '...' : d.name)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('font-size', d => d.id === centerId ? '12px' : '10px')
                    .attr('font-weight', d => d.id === centerId ? 'bold' : 'normal')
                    .attr('fill', 'white');
                
                // 更新位置
                simulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    node
                        .attr('transform', d => `translate(${d.x},${d.y})`);
                });
                
                resultDiv.innerHTML = `<span class="success">✅ 可视化渲染成功</span>\n\n渲染了 ${subgraphNodes.length} 个节点和 ${relevantLinks.length} 条连接\n中心节点: ${centerNode.name}`;
                
            } catch (error) {
                resultDiv.innerHTML = `<span class="error">❌ 可视化异常: ${error.message}</span>`;
            }
        }
    </script>
</body>
</html>

